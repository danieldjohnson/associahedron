<!doctype html>
<html>
<head>
    <title>Associahedron Explorer</title>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.js"></script>
    <script type="text/javascript" src="http://polyk.ivank.net/polyk.js"></script>
    <script type="text/javascript" src="TrackballControls.js"></script>
    <script type="text/javascript" src="Detector.js"></script>
    <script type="text/javascript" src="numeric.js"></script>
    <script type="text/javascript" src="dat.gui.min.js"></script>
<style>
#displays {
    width:100%;
    position:relative;
    border: 1px black;
}
#c1,#c2 {
    width:50%;
    height:auto;
    max-width:500px;
    /*position:absolute;*/
}
#c1{
    float:left;
}
#c2{
    /*right:0;*/
}

path.polygon {
  fill: #ccc;
}
path.polygon_fg {
  stroke: #000;
  fill: transparent;
  stroke-width: 5px;
  stroke-linecap: round;
}
path.triangulation {
  stroke: #0f0;
  fill: transparent;
  stroke-width: 3px;
  stroke-linecap: round;
  pointer-events:none;
}
circle.polygon_v {
  fill: #0dd;
  stroke: #000;
  stroke-width:1px;
}
</style>

</head>
<body>
    <div id="displays">
        <svg id="c1" width="500" height="500" viewBox="0 0 500 500"></svg>
        <canvas id="c2" width="500" height="500"></canvas>
    </div>
<script type="text/javascript" src="graphics3d.js"></script>
<script>

function flatten_arr(array){
    return array.reduce(function(a,b){return a.concat(b);},[]);
}

var width = 500, height=500;

function reset_poly(){
  for (var i = 0; i < 6; i++) {
    polygon[i] = [(width/2)+200*Math.cos(2*i*Math.PI/6), (height/2)+200*Math.sin(2*i*Math.PI/6)];
  }
}

var polygon = [];
reset_poly();
var fp = flatten_arr(polygon);
console.log(fp,PolyK.IsSimple(fp), PolyK.IsConvex(fp));

var svg = d3.select("#c1");
var polygon_path = svg.append("g").selectAll("path.polygon");
var triangulation_path = svg.append("g").selectAll("path.triangulation");
var polygon_path_fg = svg.append("g").selectAll("path.polygon_fg");
var polygon_verts = svg.append("g").selectAll("circle.polygon_v");

var gui = new dat.GUI();
var params = {
  "Reset hexagon": function(){
    reset_poly();
    redraw();
  }
};
gui.add(params, 'Reset hexagon');

// Triangulation blocks
//   All triangles from one vertex
//   N-shaped triangulations
//   Mirror N-shaped triangulation
//   Central triangle
var triangulations = [
    [[0,1,2],[0,2,3],[0,3,4],[0,4,5]],
    [[0,1,5],[1,2,3],[1,3,4],[1,4,5]],
    [[0,1,2],[0,2,5],[2,3,4],[2,4,5]],
    [[0,1,3],[1,2,3],[0,3,5],[3,4,5]],
    [[0,1,4],[1,2,4],[2,3,4],[0,4,5]],
    [[0,1,5],[1,2,5],[2,3,5],[3,4,5]],

    [[0,1,3],[1,2,3],[0,3,4],[0,4,5]],
    [[0,1,5],[1,2,4],[2,3,4],[1,4,5]],
    [[0,1,2],[0,2,5],[2,3,5],[3,4,5]],

    [[1,3,4],[1,2,3],[0,1,4],[0,4,5]],
    [[0,1,5],[1,2,5],[2,3,4],[2,4,5]],
    [[0,1,2],[0,3,5],[0,2,3],[3,4,5]],

    [[0,1,2],[0,2,4],[2,3,4],[0,4,5]],
    [[1,2,3],[0,1,5],[1,3,5],[3,4,5]]
    ];

///////////

function dragmove(d,i) {
  console.log("Drag");

  var oldx = d[0];
  var oldy = d[1];
  d[0] = d3.event.x;
  d[1] = d3.event.y;

  if(d[0]<0) d[0]=0;
  if(d[0]>width) d[0]=width;
  if(d[1]<0) d[1]=0;
  if(d[1]>height) d[1]=height;

  var fp = flatten_arr(polygon);
  if(!(PolyK.IsSimple(fp) && PolyK.IsConvex(fp))){
    d[0] = oldx;
    d[1] = oldy;
  }

  redraw();
}
var dragpoly = d3.behavior.drag().on("drag", dragmove)

function redraw(){
    polygon_path = polygon_path.data([polygon]);
    polygon_path.exit().remove();
    polygon_path.enter().append("path").attr("class","polygon");
    polygon_path.attr("d", poly_d_fn);

    polygon_path_fg = polygon_path_fg.data([polygon]);
    polygon_path_fg.exit().remove();
    polygon_path_fg.enter().append("path").attr("class","polygon_fg");
    polygon_path_fg.attr("d", poly_d_fn);

    polygon_verts = polygon_verts.data(polygon);
    polygon_verts.exit().remove();
    polygon_verts.enter().append("circle");
    polygon_verts.attr("class","polygon_v")
      .attr("transform", function(d) { return "translate(" + d + ")"; })
      .attr("r", 6)
      .call(dragpoly);

    var c_tri = [];
    if(active_triangulation !== null){
      var T = triangulations[active_triangulation];
      c_tri = T.map(function(tri){
        return tri.map(function(pt) {
          return polygon[pt];
        });
      });
    }
    triangulation_path = triangulation_path.data(c_tri);
    triangulation_path.exit().remove();
    triangulation_path.enter().append("path").attr("class","triangulation");
    triangulation_path.attr("d", poly_d_fn);

    var assoc_points = [];
    for (var i = 0; i < triangulations.length; i++) {
      var T = triangulations[i];
      assoc_points.push(area_vector(T));
    }

    var assoc;
   
    var axes = gs_orthonormalize(assoc_points);
    console.log(axes);
    assoc = project_all(assoc_points,axes);
    
    console.log(assoc);
    update_asschdron(assoc, false);
}

function poly_d_fn(d) {
  return "M" + d.join("L") + "Z";
}

// Computes the area sum of vertex v under triangulation T
function area_sum(v, T) {
  var area = 0;

  // For every triangle in T
  for (var i = 0; i < T.length; i++) {
    // If v is in the triangle
    if (T[i].indexOf(v) != -1) {
      // Flatten the triangle for PolyK
      var incidentTriangle = [];
      for (var j = 0; j < 3; ++j) {
        incidentTriangle[j] = polygon[T[i][j]];
      }
      var ft = flatten_arr(incidentTriangle);
      
      // Add the area
      area += PolyK.GetArea(ft);
    }
  }

  return area;
}

function area_vector(T) {
  var av = [];

  for (var i = 0; i < polygon.length; ++i) {
    av[i] = area_sum(i, T);
  }

  return av;
}

function pcaR6toR3(associahedron) {
  var pca = new PCA();
  associahedron = pca.scale(associahedron,true,true);
  pc = pca.pca(associahedron,3);
  output = [];
  for (var i = 0; i < pc.length; i++) {
    output[i] = pc[i].slice(0,3);
  }
  return output;
}

function axis_transpose(vects, transpose){
  var newvects = [];
  for (var i = 0; i < vects.length; i++) {
    var vect = vects[i]
    var nvect = [];
    for (var j = 0; j < vect.length; j++) {
      nvect[j] = vect[transpose[j]];
    }
    newvects.push(nvect);
  }
  return newvects;
}

function project_all(vects, axes){
  var newvects = [];
  for (var i = 0; i < vects.length; i++) {
    var vect = numeric.sub(vects[i], vects[vects.length - 1]);
    var nvect = [];
    for (var j = 0; j < axes.length; j++) {
      var axis = axes[j];
      nvect[j] = scalar_project(vect, axis);
    }
    while(nvect.length < 6){
      nvect.push(0);
    }
    newvects.push(nvect);
  }
  return newvects;
}

function scalar_project(v,axis){
  return numeric.dot(v, axis) / numeric.norm2(axis);
}

// Returns an orthonormal set of vectors spanning
// the same subspace as the input vectors
function gs_orthonormalize(vectors) {
  var orth = [];

  for (var i = 0; i < vectors.length - 1; i++) {
    orth[i] = numeric.sub(vectors[i], vectors[vectors.length - 1]);
  }

  for (var i = 0; i < orth.length; i++) {
    var magnitude = numeric.norm2(orth[i]);
    if (magnitude < .0000001) {
      orth[i] = null;
    }
    else{
      for (var j = i + 1; j < orth.length; j++) {
        innerProductQuotient = (numeric.dot(orth[j], orth[i]) /
                                numeric.dot(orth[i], orth[i]));
        proj = numeric.mul(orth[i], innerProductQuotient);
        orth[j] = numeric.sub(orth[j], proj);
      }
      orth[i] = numeric.div(orth[i], magnitude);
    }
  }

  return orth.filter(function isNull(elem) {return elem != null;});
}

///////////

init_graphics3d(width,height,document.getElementById("c2"));
redraw();
animate3d();
</script>
</body>
</html>